#!/usr/bin/env python2
# this is python2/3 compatible, but the following bug breaks us... 
# https://bugs.launchpad.net/ubuntu/+source/python-launchpadlib/+bug/1425575

# you also might need to $ sudo apt install python-apport

import os
import sys
import argparse
import tempfile
import subprocess
import shlex
import shutil
import uuid
import yaml
from collections import defaultdict
from os.path import expanduser
import apport
import apport.crashdb
import apport.hookutils
from textwrap import dedent


MAX_FILE_SIZE = 5000000 # 5MB max for files
DIRECTORIES = [
    '/var/lib/juju',
    '/var/log',
    '/etc/ceph',
    '/etc/cinder',
    '/etc/glance',
    '/etc/keystone',
    '/etc/neutron',
    '/etc/nova',
    '/etc/quantum',
    '/etc/swift',
    '/opt/nedge/var/log',
    '/usr/share/lxc/config',
    '/var/lib/libvirt/filesystems/plumgrid-data/log',
    '/var/lib/libvirt/filesystems/plumgrid/var/log',
]
TIMEOUT = 45

TAR_CMD = """sudo find {dirs} -mount -type f -size -{max_size}c -o \
-size {max_size}c 2>/dev/null | sudo tar -cf /tmp/juju-dump-{uuid}.tar \
--files-from - 2>/dev/null"""
SOS_CMD = """& sudo apt-get install -qy sosreport 2>/dev/null 1>&2; \
sudo mkdir /tmp/{uuid}; sudo sosreport --batch --quiet --build {sos_options} \
--tmp-dir=/tmp/{uuid} 2>/dev/null; wait; \
sudo tar -rf /tmp/juju-dump-{uuid}.tar -C /tmp/{uuid}/*/ * 2>/dev/null"""


def service_unit_addresses(status):
    """From a given juju_status.yaml dict return a mapping of
    {'machine/container': ['<service1>', '<service2>', '<ip>']}."""
    machines = {}
    services = defaultdict(set)
    units = set()
    for m_id, m_info in status['machines'].items():
        if 'dns-name' not in m_info:
            continue
        machines["machine%s/baremetal" % m_id] = m_info['dns-name']
        services[m_info['dns-name']].add(m_info['dns-name'])
        for c_id, c_info in m_info.get('containers', {}).items():
            if 'dns-name' not in c_info:
                continue
            machines["machine%s/container%s" % (m_id, c_id)] = \
                m_info['dns-name']
            services[c_info['dns-name']].add(c_info['dns-name'])

    for _, a_info in status['applications'].items():
        if 'subordinate-to' in a_info:
            continue
        for u_id, u_info in a_info.get('units', {}).items():
            if 'public-address' not in u_info:
                continue
            addr = u_info['public-address']
            services[addr].add(u_id)
            units.add(u_id)
            if 'subordinates' in u_info:
                for s_id, s_info in u_info['subordinates'].items():
                    if 'public-address' not in s_info:
                        continue
                    addr = s_info['public-address']
                    services[addr].add(s_id)

    out = {machine_name: services[ip] for machine_name, ip in machines.items()}

    return out, units


def set_model(model):
    os.environ['JUJU_ENV'] = model
    os.environ['JUJU_MODEL'] = model


def run_cmd(command):
        subprocess.check_call(command, shell=True)


def juju_cmd(command):
    command_prefix = 'juju '
    run_cmd(command_prefix + command)


def juju_status():
    juju_cmd('status --format=yaml > juju_status.yaml')


def juju_debuglog():
    juju_cmd('debug-log --replay --no-tail > debug_log.txt')


class CrashCollector(object):
    """A log file collector for juju and charms"""
    def __init__(self, model, **kwargs):
        if model:
            set_model(model)
        self.context = kwargs
        self.cwd = os.getcwd()
        self.tempdir = tempfile.mkdtemp(dir=expanduser('~'))
        os.chdir(self.tempdir)
        self.uuid = uuid.uuid4()

    def create_unit_tarballs(self):
        print("Collating data on the nodes...")
        directories = list(self.context['extra_dirs'])
        directories.extend(
            ['/var/lib/lxd/containers/*/rootfs' + item for item in directories]
        )
        command = TAR_CMD
        if self.context['enable_sos']:
            command += SOS_CMD
        command = command.format(dirs=" ".join(directories), uuid=self.uuid,
                **self.context)
        try:
            run_cmd("""timeout %ss juju run --all 'sh -c "%s"'"""
                    % (self.context['timeout'], command))
        except subprocess.CalledProcessError:
            print("Could not retrieve logs from all systems, will still " \
                  "use what was available.")


    def retrieve_unit_tarballs(self):
        print("Pulling data from the nodes...")
        juju_status = yaml.load(open('juju_status.yaml', 'r'))
        aliases, units = service_unit_addresses(juju_status) 
        for machine, alias_group in aliases.items():
            any_unit = alias_group.intersection(units).pop()
            juju_cmd("scp %s:/tmp/juju-dump-%s.tar ." % (any_unit, self.uuid))
            run_cmd("mkdir -p %s || true" % machine)
            run_cmd("tar -pxf juju-dump-%s.tar -C %s" % (self.uuid, machine))
            run_cmd("rm juju-dump-%s.tar" % self.uuid)
            for alias in alias_group:
                os.symlink('%s' % machine, '%s' % alias.replace('/', '_'))

    def collect(self):
        juju_status()
        juju_debuglog()
        self.create_unit_tarballs()
        self.retrieve_unit_tarballs()
        print("Compressing data locally...")
        tar_file = "juju-crashdump-%s.tar" % self.uuid
        try:
            run_cmd("tar -cf %s * 2>/dev/null" % tar_file)
        except:
            pass # ignore not being able to tar some links
        run_cmd("gzip --force %s" % tar_file)
        os.chdir(self.cwd)
        gzipped_file = tar_file + '.gz'
        shutil.move(os.path.join(self.tempdir, gzipped_file), '.')
        self.cleanup()
        print("Saved crasdump to: %s" % gzipped_file)
        return gzipped_file

    def cleanup(self):
        shutil.rmtree(self.tempdir)


def upload_file_to_bug(bugnum, file_):
    crashdb = crashdb = apport.crashdb.get_crashdb(None)
    if not crashdb.can_update(bugnum):
        print(dedent("""
            You are not the reporter or subscriber of this problem report,
            or the report is a duplicate or already closed.
            
            Please create a new report on https://bugs.launchpad.net/charms.
            """))
        return False

    is_reporter = crashdb.is_reporter(bugnum)

    report = apport.Report('Bug')
    apport.hookutils.attach_file(report, file_, overwrite=False)
    if len(report) != 0:
        print("Starting upload to lp:%s" % bugnum)
        crashdb.update(bugnum, report,
        'apport information', change_description=is_reporter,
        attachment_comment='juju crashdump')


class ShowDescription(argparse.Action):
    """Helper for implementing --description using argparse"""
    def __init__(self, *args, **kwargs):
        super(ShowDescription, self).__init__(*args, **kwargs)

    def __call__(self, parser, *args, **kwargs):
        print(CrashCollector.__doc__)
        sys.exit(0)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--description', nargs=0, action=ShowDescription,
                        help='Output a short description of the plugin')
    parser.add_argument('-m', '--model', default=None,
                        help='Model to act on')
    parser.add_argument('-f', '--max-file-size',  default=MAX_FILE_SIZE,
                        help='The max file size (bytes) for included files')
    parser.add_argument('-s', '--enable-sos', action='store_true',
                        default=False, help='Include sosreport with the dump')
    parser.add_argument('-S', '--sos-options',  default='',
                        help='Extra options to pass to sosreport')
    parser.add_argument('-b', '--bug', default=None,
                        help='Upload crashdump to the given launchpad bug #')
    parser.add_argument('extra_dir', nargs='*', default=DIRECTORIES,
                        help='Extra directories to snapshot')
    parser.add_argument(
        '-t', '--timeout', default=TIMEOUT,
        help='Timeout for collating the data on nodes (seconds)'
    )
    return parser.parse_args()


def main():
    opts = parse_args()
    collector = CrashCollector(model=opts.model, max_size=opts.max_file_size,
                               extra_dirs=opts.extra_dir,
                               sos_options=opts.sos_options,
                               enable_sos=opts.enable_sos, timeout=opts.timeout)
    filename = collector.collect()
    if opts.bug:
        upload_file_to_bug(opts.bug, filename)


if __name__ == '__main__':
    main()
